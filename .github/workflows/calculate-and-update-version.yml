name: Calculate and Update Version

on:
  workflow_call:
    inputs:
      branch:
        description: 'Branch/ref to checkout and work with'
        required: false
        type: string
        default: ''
      version_strategy:
        description: 'Version calculation strategy: increment, override, production-rc, or production-release'
        required: true
        type: string
      base_version_from_branch:
        description: 'If true, extract base version from branch name (e.g., release/v1.1.1 -> 1.1.1)'
        required: false
        type: boolean
        default: false
    outputs:
      new_tag:
        description: 'The newly calculated tag name'
        value: ${{ jobs.calculate-and-update-version.outputs.new_tag }}
      new_version:
        description: 'The newly calculated version'
        value: ${{ jobs.calculate-and-update-version.outputs.new_version }}

permissions:
  contents: write

jobs:
  calculate-and-update-version:
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.calculate-version.outputs.new_tag }}
      new_version: ${{ steps.calculate-version.outputs.new_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch || github.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Extract version from branch name
        id: branch-version
        if: inputs.base_version_from_branch == true
        run: |
          # Determine the branch name
          if [ -n "${{ inputs.branch }}" ]; then
            BRANCH_NAME="${{ inputs.branch }}"
          else
            BRANCH_NAME="${GITHUB_REF_NAME}"
          fi
          
          # Extract version from branch name (e.g., release/v1.2.3 -> 1.2.3)
          # Support formats: release/v1.2.3, release/1.2.3, v1.2.3, 1.2.3
          if [[ "$BRANCH_NAME" =~ (release/)?v?([0-9]+\.[0-9]+\.[0-9]+) ]]; then
            BASE_VERSION="${BASH_REMATCH[2]}"
            echo "Extracted version $BASE_VERSION from branch: $BRANCH_NAME"
            echo "base_version=$BASE_VERSION" | tee -a $GITHUB_OUTPUT
          else
            echo "ERROR: Failed to extract version from branch name: $BRANCH_NAME"
            echo "Expected format: release/vX.Y.Z or release/X.Y.Z"
            exit 1
          fi

      - name: Extract version info from package.json
        id: pkg-version
        if: inputs.base_version_from_branch == false
        run: |
          # Read the "version" field from package.json using Node.
          # Example output: "1.2.3-rc4" or "1.2.3"
          PACKAGE_VERSION=$(node -p "require('./package.json').version")

          # Extract only the base semantic version (major.minor.patch).
          # Example: 1.2.3-rc5 â†’ 1.2.3
          BASE_VERSION=$(echo "$PACKAGE_VERSION" | sed -E 's/^([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
    
          # âœ… VALIDATION â€” Fail the workflow if the base version is empty or invalid.
          if [[ ! "$BASE_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ ERROR: Failed to extract a valid base version from package.json."
            echo "The version found was: '$PACKAGE_VERSION'"
            echo "Expected formats: 'x.y.z' or 'x.y.z-rcN'"
            exit 1
          fi

          # Detect RC number (if any)
          if [[ "$PACKAGE_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+-rc([0-9]+)$ ]]; then
            PKG_RC_NUMBER="${BASH_REMATCH[1]}"
          else
            PKG_RC_NUMBER="0"
          fi

          # Output extracted values for later steps
          echo "package_version=$PACKAGE_VERSION" | tee -a $GITHUB_OUTPUT
          echo "base_version=$BASE_VERSION" | tee -a $GITHUB_OUTPUT
          echo "rc_number=$PKG_RC_NUMBER" | tee -a $GITHUB_OUTPUT

      - name: Get latest RC tag
        id: get-latest-rc
        run: |
          # Fetch all tags
          git fetch --tags || true
          
          if [ "${{ inputs.base_version_from_branch }}" = "true" ]; then
            BASE_VERSION="${{ steps.branch-version.outputs.base_version }}"
          else
            BASE_VERSION="${{ steps.pkg-version.outputs.base_version }}"
          fi
          
          # Get the latest RC tag for this base version (format: vX.Y.Z-rcN)
          LATEST_RC_TAG=$(git tag -l "v${BASE_VERSION}-rc*" | sort -V | tail -1)
          
          # Extract RC number if a matching tag exists; accept optional suffix like -signed
          if [[ "$LATEST_RC_TAG" =~ ^v${BASE_VERSION}-rc([0-9]+)(-.+)?$ ]]; then
            LATEST_RC_NUMBER="${BASH_REMATCH[1]}"
          else
            echo "No RC tags found for base version $BASE_VERSION. Using RC=0."
            LATEST_RC_NUMBER="0"
          fi

          echo "latest_rc_tag=$LATEST_RC_TAG" | tee -a $GITHUB_OUTPUT
          echo "latest_rc_number=$LATEST_RC_NUMBER" | tee -a $GITHUB_OUTPUT
          echo "base_version=$BASE_VERSION" | tee -a $GITHUB_OUTPUT

      - name: Calculate new version
        id: calculate-version
        run: |
          STRATEGY="${{ inputs.version_strategy }}"
          
          if [ "${{ inputs.base_version_from_branch }}" = "true" ]; then
            BASE_VERSION="${{ steps.branch-version.outputs.base_version }}"
          else
            BASE_VERSION="${{ steps.pkg-version.outputs.base_version }}"
          fi
          
          # Set tag suffix, commit message suffix, delete tag flag, and message prefix based on strategy
          if [ "$STRATEGY" = "production-release" ]; then
            # Production release: no RC number
            TAG_SUFFIX="-signed"
            COMMIT_SUFFIX="[skip release]"
            DELETE_EXISTING_TAG="false"
            TAG_MESSAGE_PREFIX="Production Release"
            NEW_VERSION="$BASE_VERSION"
            NEW_TAG="v$NEW_VERSION$TAG_SUFFIX"
          elif [ "$STRATEGY" = "production-rc" ]; then
            # Production RC strategy: increment RC number for release branches
            TAG_SUFFIX="-signed"
            COMMIT_SUFFIX="[skip release]"
            DELETE_EXISTING_TAG="false"
            TAG_MESSAGE_PREFIX="Production RC Release"
            LATEST_RC_NUMBER="${{ steps.get-latest-rc.outputs.latest_rc_number }}"
            NEW_RC_NUMBER=$((LATEST_RC_NUMBER + 1))
            NEW_VERSION="$BASE_VERSION-rc$NEW_RC_NUMBER"
            NEW_TAG="v$NEW_VERSION$TAG_SUFFIX"
          elif [ "$STRATEGY" = "override" ]; then
            # Override: use the same RC/version as package.json (dangerous)
            TAG_SUFFIX=""
            COMMIT_SUFFIX=""
            DELETE_EXISTING_TAG="true"
            TAG_MESSAGE_PREFIX="Feature Release"
            NEW_RC_NUMBER="${{ steps.pkg-version.outputs.rc_number }}"
            NEW_VERSION="${{ steps.pkg-version.outputs.package_version }}"
            NEW_TAG="v$NEW_VERSION$TAG_SUFFIX"
          else
            # Default behavior: increment
            # This is MUCH safer than falling into override mode accidentally
            TAG_SUFFIX=""
            COMMIT_SUFFIX=""
            DELETE_EXISTING_TAG="false"
            TAG_MESSAGE_PREFIX="Feature Release"
            LATEST_RC_NUMBER="${{ steps.get-latest-rc.outputs.latest_rc_number }}"
            NEW_RC_NUMBER=$(( LATEST_RC_NUMBER + 1 ))
            NEW_VERSION="$BASE_VERSION-rc$NEW_RC_NUMBER"
            NEW_TAG="v$NEW_VERSION$TAG_SUFFIX"
          fi

          echo "new_version=$NEW_VERSION" | tee -a $GITHUB_OUTPUT
          echo "new_tag=$NEW_TAG" | tee -a $GITHUB_OUTPUT
          echo "new_rc_number=$NEW_RC_NUMBER" | tee -a $GITHUB_OUTPUT
          echo "commit_suffix=$COMMIT_SUFFIX" | tee -a $GITHUB_OUTPUT
          echo "delete_existing_tag=$DELETE_EXISTING_TAG" | tee -a $GITHUB_OUTPUT
          echo "tag_message_prefix=$TAG_MESSAGE_PREFIX" | tee -a $GITHUB_OUTPUT

      - name: Update package.json version
        run: |
          NEW_VERSION="${{ steps.calculate-version.outputs.new_version }}"
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          if [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
            npm version "$NEW_VERSION" --no-git-tag-version
            echo "Updated package.json version from $CURRENT_VERSION to $NEW_VERSION"
          else
            echo "package.json version is already $NEW_VERSION, skipping update"
          fi

      - name: Update pyproject.toml version
        run: |
          NEW_VERSION="${{ steps.calculate-version.outputs.new_version }}"
          CURRENT_VERSION=$(grep -E '^version = ' pyproject.toml | sed -E 's/^version = "(.+)"/\1/')
          if [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
            sed -i -E "s/^version = \".*\"/version = \"$NEW_VERSION\"/" pyproject.toml
            echo "Updated pyproject.toml version from $CURRENT_VERSION to $NEW_VERSION"
          else
            echo "pyproject.toml version is already $NEW_VERSION, skipping update"
          fi

      - name: Commit and push version update
        run: |
          git add package.json pyproject.toml
          if git diff --staged --quiet; then
            echo "No version file changes detected â€” skipping commit."
          else
            COMMIT_MSG="chore: bump version to ${{ steps.calculate-version.outputs.new_version }}"
            COMMIT_SUFFIX="${{ steps.calculate-version.outputs.commit_suffix }}"
            if [ -n "$COMMIT_SUFFIX" ]; then
              COMMIT_MSG="$COMMIT_MSG $COMMIT_SUFFIX"
            fi
            git commit -m "$COMMIT_MSG"
            
            # Determine branch to push to
            if [ -n "${{ inputs.branch }}" ]; then
              PUSH_BRANCH="${{ inputs.branch }}"
            else
              PUSH_BRANCH="${GITHUB_REF_NAME}"
            fi
            git push origin "$PUSH_BRANCH"
          fi

      - name: Create and push tag
        run: |
          TAG_NAME="${{ steps.calculate-version.outputs.new_tag }}"
          TAG_MESSAGE_PREFIX="${{ steps.calculate-version.outputs.tag_message_prefix }}"
          DELETE_EXISTING_TAG="${{ steps.calculate-version.outputs.delete_existing_tag }}"

          echo "ðŸ”§ Tag name: $TAG_NAME"
          echo "ðŸ”§ Delete existing tag: $DELETE_EXISTING_TAG"
          echo "ðŸ”§ Tag message prefix: $TAG_MESSAGE_PREFIX"
          
          # Validate tag name is not empty
          if [ -z "$TAG_NAME" ]; then
            echo "ERROR: TAG_NAME is empty. Cannot create tag."
            exit 1
          fi
          
          # Delete tag locally if it exists (for feature releases)
          if [ "$DELETE_EXISTING_TAG" = "true" ]; then
            git tag -d "$TAG_NAME" 2>/dev/null || true
            # Delete tag remotely if it exists
            git push origin --delete "$TAG_NAME" 2>/dev/null || true
          fi
          
          # Create and push the new tag
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE_PREFIX $TAG_NAME"
          git push origin "$TAG_NAME"
          echo "Successfully created and pushed tag: $TAG_NAME"
